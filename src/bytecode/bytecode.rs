#[derive(Debug, PartialEq, Clone)]
pub enum Op {
    LOADCONST,
    LOADVAR,
    STOREVAR,
    ADD,
    SUB,
    MUL,
    DIV,
    NEG,
    POS,
    INC,
    DEC,
    LOGNOT,
    LOGAND,
    LOGOR,
    LOGXOR,
    EQ,
    NE,
    GT,
    GE,
    LT,
    LE,
    AND,
    OR,
    POP,
    JUMP,
    JUMPIFFALSE,
    CALL,
    RET,
    EXIT,
    HALT,
}
impl Op {
    pub fn from_u8(op: u8) -> Option<Self> {
        match op {
            0 => Some(Op::LOADCONST),
            1 => Some(Op::LOADVAR),
            2 => Some(Op::STOREVAR),
            3 => Some(Op::ADD),
            4 => Some(Op::SUB),
            5 => Some(Op::MUL),
            6 => Some(Op::DIV),
            7 => Some(Op::NEG),
            8 => Some(Op::POS),
            9 => Some(Op::INC),
            10 => Some(Op::DEC),
            11 => Some(Op::LOGNOT),
            12 => Some(Op::LOGAND),
            13 => Some(Op::LOGOR),
            14 => Some(Op::LOGXOR),
            15 => Some(Op::EQ),
            16 => Some(Op::NE),
            17 => Some(Op::GT),
            18 => Some(Op::GE),
            19 => Some(Op::LT),
            20 => Some(Op::LE),
            21 => Some(Op::AND),
            22 => Some(Op::OR),
            23 => Some(Op::POP),
            24 => Some(Op::JUMP),
            25 => Some(Op::JUMPIFFALSE),
            26 => Some(Op::CALL),
            27 => Some(Op::RET),
            28 => Some(Op::EXIT),
            29 => Some(Op::HALT),
            _ => None,
        }
    }

    pub fn to_str(op: Op) -> String {
        match op {
            Op::LOADCONST => "LOAD_CONST".to_string(),
            Op::LOADVAR => "LOAD_VAR".to_string(),
            Op::STOREVAR => "STORE_VAR".to_string(),
            Op::ADD => "ADD".to_string(),
            Op::SUB => "SUB".to_string(),
            Op::MUL => "MUL".to_string(),
            Op::DIV => "DIV".to_string(),
            Op::NEG => "NEG".to_string(),
            Op::POS => "POS".to_string(),
            Op::INC => "INC".to_string(),
            Op::DEC => "DEC".to_string(),
            Op::LOGNOT => "LOG_NOT".to_string(),
            Op::LOGAND => "LOG_AND".to_string(),
            Op::LOGOR => "LOG_OR".to_string(),
            Op::LOGXOR => "LOG_XOR".to_string(),
            Op::EQ => "EQ".to_string(),
            Op::NE => "NE".to_string(),
            Op::GT => "GT".to_string(),
            Op::GE => "GE".to_string(),
            Op::LT => "LT".to_string(),
            Op::LE => "LE".to_string(),
            Op::AND => "AND".to_string(),
            Op::OR => "OR".to_string(),
            Op::POP => "POP".to_string(),
            Op::JUMP => "JUMP".to_string(),
            Op::JUMPIFFALSE => "JUMP_IF_FALSE".to_string(),
            Op::CALL => "CALL".to_string(),
            Op::RET => "RET".to_string(),
            Op::EXIT => "EXIT".to_string(),
            Op::HALT => "HALT".to_string(),
        }
    }

    pub fn operand_count(&self) -> usize {
        match self {
            Op::LOADCONST => 1,
            Op::LOADVAR => 1,
            Op::STOREVAR => 1,
            Op::ADD => 0,
            Op::SUB => 0,
            Op::MUL => 0,
            Op::DIV => 0,
            Op::NEG => 0,
            Op::POS => 0,
            Op::INC => 0,
            Op::DEC => 0,
            Op::LOGNOT => 0,
            Op::LOGAND => 0,
            Op::LOGOR => 0,
            Op::LOGXOR => 0,
            Op::EQ => 0,
            Op::NE => 0,
            Op::GT => 0,
            Op::GE => 0,
            Op::LT => 0,
            Op::LE => 0,
            Op::AND => 0,
            Op::OR => 0,
            Op::POP => 0,
            Op::JUMP => 2,
            Op::JUMPIFFALSE => 2,
            Op::CALL => 3,
            Op::RET => 0,
            Op::EXIT => 0,
            Op::HALT => 0,
        }
    }
}
